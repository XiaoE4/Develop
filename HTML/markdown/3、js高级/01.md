# JavaScript高级

# ajax

## 1.认识

```javascript
//1. 创建XHR
let xhr = new XMLHttpRequest( )
console.log(xhr)

// 2.配置open，规定请求（请求方式，请求地址，同步和异步(true&false)）
// localhost 本机域名 127.0.0.1 本机ip (live server)
// 请求方式：GET和POST：
/*
与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。
然而，在以下情况中，请使用 POST 请求：
    1. 不愿使用缓存文件（更新服务器上的文件或数据库）
    2. 向服务器发送大量数据（POST 没有数据量限制）
    3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
*/
xhr.open("GET","输入请求的地址",true&false)
//true表示异步
//false表示同步

//3. send	将请求发送到服务器
xhr.send()

// 4.接收数据，注册一个事件
xhr.onreadystatechange= fn1=>{
    console.;og("xhr.readyState")
    if(xhr.readyState === 4 && xhr.status=== 200){
        console.log("解析完成",xhr.responseText)
    }  else if(xhr.readyState ===4 && xhr.status ===404){
		console.log("没有找到")
        //location.href="404.html"
    }
}
xhr.onload =fn2=>{
	console.log("onload",xhr.readyState)	
    if(xhr.status===200){
                console.log(JSON.parse(xhr.responseText));
            }else if (xhr.status===404){
                console.error("not found")
            }
}
```



## 2.请求方式（json-server）

form get post

#### 1.get 偏向获取数据

```javascript
xhr.open("GET","http://localhost:3000/users")
// xhr.open("GET","http://localhost:3000/users?username=xiaoE")添加?username=xiaoE为定点查找所有username为xiaoE的，或者输全表单内容进行查找匹配?username=xiaoE&password=123
if(xhr.status===200){
    //if（^2\d{2|$/.test(xhr.status)）{ }
    ///^2\d{2|$/.test(xhr.status)	status=200-299均为正确，这样写可以判断是否在这个范围内
    console.log(JSON.parse(xhr.responseText));
}
```

#### 2.post 偏向提交数据

```javascript
xhr.open("POST","http://localhost:3000/users")

            xhr.onload = function(){
                if(/^2\d{2|$/.test(xhr.status)){
                    console.log(JSON.parse(xhr.responseText));
                }
                //提交信息
                // 第一种：post name=xiaoE&age=20
                xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded")
                xhr.send(`username=xiaoB&password=123`)
                // 第二种：post{"name":"xiaoE","age":20}
                xhr.setRequestHeader("Content-Type","application/json")
                xhr.send(JSON.stringify({
                    username:"xiaoE",
                    password:"987"
            }))
```



#### 3.put 偏向更新（覆盖修改）

```javascript
xhr.open("PUT","http://localhost:3000/users/1")	//user/id
//其余和post一样，更新为覆盖更新，如原有name和age，更新只写了name，则age也被覆盖消失，数据内只剩下name
```



#### 4.delete 偏向删除信息

```javascript
xhr.open("DELETE","http://localhost:3000/users/1")//user/id
	xhr.setRequestHeader("Content-Type","application/json")
        xhr.send()
```



#### 5.patch	偏向部分修改（不覆盖）

```javascript
xhr.open("PATCH","http://localhost:3000/users/1")//user/id
xhr.setRequestHeader("Content-Type","application/json")
            xhr.send(JSON.stringify({
                username:"xiaoE123",
            }))
//修改后原有的其他内容依然存在，不进行覆盖
```

open里面第一个词为使用的功能（get、post、put、delete、patch）

  - header
  - option
  - connect


## 3.nodejs的使用和问题

`npm install json-server -g`		//终端下载json-server

`json-server` -基于一个json文件就可以创建很多的后端模拟接口

问题：系统禁止运行脚本，npm fund，清除缓存。

正常使用：右键终端运行，输入`json-server .\test1.json --watch` 	//数据为test1.json

- 端口占用：

  输入：`netstat -ano` 查看端口

  在cmd 输入 `taskkill /f /t /im` 对应的 TCP 号（最后面的一串数字），来关掉被占用的端口，之后再次运行使用。

## 4.封装

url：传输地址

method：请求方式（GET,POST···）

async：是否异步

data：数据

headers：{

```javascript
// "Content-Type":"application/x-www-form-urlencoded"
"content-type":"application/json"
```

}

success：成功回调函数

error：失败回调函数

![66607799509](C:\Users\小饿\AppData\Local\Temp\1666077995096.png)

#  Promise

解决回调地狱的一种方法

##  1.基础语法

`resolve`和`reject`

`q.then(fn(  ){	}).catch(fn(  ){  })`

```javascript
// Promise构造函数
//承诺对象 q
var q=new Promise(function(resolve,reject){
                  setTimeout(()=>{
                  //成功兑现承诺
                  resolve(["111","222","333"])
		 //失败拒绝承诺
		 reject("err0r")
                  },2000)
                  })
                  // pending 执行中
                  //fulfilled 成功
                  //reject 拒绝
                  
                  //q就是Promise对象
                  q.then(function(res){
                      // 兑现承诺，这个函数被执行
                      console.log("success",res)
                  }).catch(function(err){
                      // 拒绝承诺，这个函数就会被执行
                      console.log("fail",err)
                  })
```

## 2.封装ajax

then后面紧跟着then，执行时为链式依次执行，then后的pajax在前面加上return返回，最后加上catch，如果then出错则直接跳到catch。
相比于在success内嵌套ajax更加简洁，便于查看，解决回调地狱。

```javascript
pajax({
            url: "http://localhost:3000/news",
            data: {
                author: "kerwin"
            }
        }).then(res => {
            // console.log("success",res);
            return pajax({
                url: "http://localhost:3000/comments",
                data: {
                    newsId: res[0].id
                }
            })
            }).then(res => {
                console.log("success",res);
        }).catch(err=>{
            console.log("fail",err);
        })

```



## 3.promise.all

`primise.all`：并发处理

```javascript
console.log("正在加载")
let q1 =pajax({
    url:"http://localhost:3000/looplist"
})
let q2=pajax({
    url:"http://localhost:3000/datalist"
})

Promise.all([q1,q2]).then(res=>{
    console.log(res)
    console.log("隐藏加载")
}).catch(err=>{
    console.log(err)
})
// q1和q2并发处理，处理完再进行log打印，如果一个错误则catch错误。
```

# async和await

## 1.使用方法

适用于链式调用，可以简化代码

```javascript
async function test() {
            // await同步代码/ promise对象
            var res = await pajax({
                url:"http://localhost:3000/news",
                data:{
                    author:"kerwin"
                }
            })
            // console.log(res);
            var res2 =pajax({
                url: "http://localhost:3000/comments",
                data: {
                    newsId: res[0].id
                }
            })

            return res2
        }

        test().then(res=>{
            console.log("返回结果：",res);
        }).catch(err=>{
            console.log(err);
        })

        test()
```



##  2. async函数里怎么捕获错误

利用`try，catch`捕获错误

```javascript
try{
    var res1 = await pajax({
        url:"http://localhost:3000/news"
        data:{
        	author:"kerwin"
    	}
    })
    var res2 = await pajax({
	url:"http://localhost:3000/comments"
        data:{
        	newsId:res[0].id
    	}
    })
    console.log("success",res1) 
}catch(err){
    console.log(err)
}
```

# fetch

```javascript
// 读取和判断
let username="xiaoE"
fetch(`http://localhost:3000/user?username=${username}`).then(res=>{
    console.log(res)
    // 把数据按照json类型读出来
    if(res.ok){
        return res.json()
    }else{
        // 拒绝
        return Promise.reject({
            a:1,
            status:res.status,
            statusText:res.statusText
        })
    }
    // 默认执行完这个then后直接执行下一个then，无论这个then是否错误
}).then(res=>{
    console.log("success",res)
}).catch(err=>{
    console.log("error",err)
})			// 默认不会走catch，所以要对res加以判断进行拒绝承诺。这样才会走catch返回err
```

↓	在fetch内添加其他内容，需要在括号内的url外加逗号和大括号进行添加，之后添加输出`res.json( )`

```javascript
// 在fetch内添加其他内容
fetch("http://localhost:3000/users/2",{
    method:"PUT",
    headers:{
	"content-type":"application/json"
    },
    body:JSON.stringify({
	username:"xigema"
    })
}).then(res=>res.json())
    .then(res=>{
    	console.log(res)
})

// fetch("http://localhost:3000/looplist").then(res=>res.json())
```

json-server:

接口分析：![66616262173](C:\Users\小饿\AppData\Local\Temp\1666162621733.png)

page=1：第一页，limit=3：每页3个数据（id为1、2、3的数据）

